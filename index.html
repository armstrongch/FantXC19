<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>FantXC Simulator 2019</title>
	</head>
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
	<body onload="setupGame()">
		<p id="testP"></p>
		
		<script>
			var runnerList = [];
			var finisherList = [];
			var handSize = 3;

			var cardList = 
			{
				"Run": new card(1000, 10, ""),
				"Surge": new card(1400, 20, ""),
				"Fatigue": new card(600, 0, ""),
				"Recover": new card(800, 5, "Gain 10% Energy"),
				"Kick": new card(1600, 6, "Expends all available Energy"),
				"Coast": new card(1000, 4, "Can only be used while running with a pack")
			};

			function getCardPriority(runner, cardName)
			{
				var priority = 0;
				if (runner.energy < cardList[cardName].energy * (1 + runner.exhaustion))
				{
					priority -= 10000;
				}
				
				switch(cardName)
				{
					case "Kick":
						priority += cardList[cardName].distance;
						var distanceFromFinishAfterKick = 10000 - runner.position - cardList[cardName].distance;
						priority -= distanceFromFinishAfterKick;
						break;
					default:
						priority += cardList[cardName].distance;
						break;
				}
				return priority;
			}

			function card(distance, energy, specialText)
			{
				this.distance = distance;
				this.energy = energy;
				this.specialText = specialText;
			}

			function setupGame()
			{
				setupRace(3);
				runRace();
			}

			function setupRace(numRunners)
			{
				runnerList = [];
				finisherList = [];
				for (let i = 0; i < numRunners; i++)
				{
					var runner = new createRunner(runnerList);
					shuffle(runner.deck);
					//deck.length MUST be more than handSize, or this WILL break
					for (let i = 0; i < handSize; i++)
					{
						runner.hand.push(runner.deck.pop());
					}
					runnerList.push(runner);
				}
				showMessage("Race will have " + numRunners + " runners.");
			}

			function runRace()
			{
				while (runnerList.length > finisherList.length)
				{
					raceRound();
					updateFinisherList(); //Also updates positionBeforeMoving
				}
			}
			
			function updateFinisherList()
			{
				//Using a temporary list in case we want to introduce an additional tiebreaker later
				var finishersThisTurn = [];
				for (let i = 0; i < runnerList.length; i++)
				{
					var runner = runnerList[i];
					runner.positionBeforeMoving = runner.position;
					if ((runner.position >= 10000) && (runner.finished == false))
					{
						finishersThisTurn.push(runner);
						runner.finished = true;
					}
				}
				finishersThisTurn.sort(dynamicSort("position"));
				for (let i = 0; i < finishersThisTurn.length; i ++)
				{
					finisherList.push(finishersThisTurn[i]);
					showMessage("Runner " + finishersThisTurn[i].id + " finishes in " + ordinal_suffix_of(finisherList.length) + " place.");
				}
			}
			
			function raceRound()
			{
				showMessage(finisherList.length + " of " + runnerList.length + " runners have finished.");
				runnerList.sort(dynamicSort("position"));
				
				for (let i = 0; i < runnerList.length; i++)
				{
					var runner = runnerList[i];
					if (runner.position < 10000)
					{
						runner.hand.sort(
							function(a,b)
							{
								return getCardPriority(runner, b) - getCardPriority(runner, a);
							}
						);
						
						var isCoastValid = false;
						for (let j = 0; j < runnerList.length; j++)
						{
							var anotherRunner = runnerList[j];
							if ((anotherRunner.positionBeforeMoving == runner.position) && (anotherRunner.id != runner.id))
							{
								isCoastValid = true;
								j = runnerList.length;
							}
						}
						
						var cardToPlayIndex = 0;
						while 
						(
							(cardToPlayIndex <= runner.hand.length - 1) //cardToPlayIndex is in hand
							&& 
							(
								(cardList[runner.hand[0]].energy * (1 + runner.exhaustion) > runner.energy) //Card costs too much
								|| ((!isCoastValid) && (runner.hand[cardToPlayIndex] == "Coast")) //Card is Coast and !isCoastValid
							)
						)
						{
							cardToPlayIndex++;
						}
						
						
						if (cardToPlayIndex <= runner.hand.length - 1)
						{
							playCard(runner, runner.hand[cardToPlayIndex]);
							runner.discard.push(runner.hand[cardToPlayIndex]);
							runner.hand.splice(cardToPlayIndex, 1);
						}
						else
						{
							playCard(runner, "Fatigue");
						}
						if (runner.deck.length > 0)
						{
							runner.hand.push(runner.deck.pop());
						}
					}
				}
			}

			function playCard(runner, cardName)
			{
				//when cardHandIndex == -1, play fatigue
				var card = cardList[cardName];
				runner.position += card.distance;
				runner.energy -= card.energy * (1 + runner.exhaustion);
				if (cardName == "Recover")
				{
					runner.energy += 10;
				}
				else if (cardName == "Kick")
				{
					runner.energy = 0;
				}
				var distanceFromFinish = 10000 - runner.position;
				
				if (runner.position < 10000)
				{
					showMessage("Runner " + runner.id + " plays " + cardName + " (" + distanceFromFinish + " meters from the finish, " + runner.energy + "% energy remaining).");
				}
				else
				{
					showMessage("Runner " + runner.id + " plays " + cardName + " and crosses the finish line.");
				}
			}
			
			function createRunner(runnerList)
			{
				this.isPlayer = false;
				this.id = runnerList.length;
				this.position = 0;
				this.positionBeforeMoving = 0;
				this.energy = 100;
				this.deck = ["Run", "Run", "Run", "Surge", "Surge", "Recover", "Recover", "Kick", "Coast", "Coast"];
				this.hand = [];
				this.discard = [];
				this.finished = false;
				this.exhaustion = 0;
			}

			//From Stack Overflow: https://stackoverflow.com/questions/1129216/sort-array-of-objects-by-string-property-value
			function dynamicSort(property) 
			{
				var sortOrder = 1;

				if(property[0] === "-") 
				{
					sortOrder = -1;
					property = property.substr(1);
				}
				return function (a,b) 
				{
					var result = (a[property] < b[property]) ? -1 : (a[property] > b[property]) ? 1 : 0;
					return result * sortOrder;
				}
			}

			//From: https://javascript.info/task/shuffle
			function shuffle(array) 
			{
				array.sort(() => Math.random() - 0.5);
			}
			
			//From: https://stackoverflow.com/questions/13627308/add-st-nd-rd-and-th-ordinal-suffix-to-a-number
			function ordinal_suffix_of(i) 
			{
				var j = i % 10,
					k = i % 100;
				if (j == 1 && k != 11) {
					return i + "st";
				}
				if (j == 2 && k != 12) {
					return i + "nd";
				}
				if (j == 3 && k != 13) {
					return i + "rd";
				}
				return i + "th";
			}
			
			function showMessage(text)
			{
				if ($('#testP').html().length == 0)
				{
					$('#testP').html(text);
				}
				else
				{
					$('#testP').html(
						$('#testP').html()
						+ "<br/>"
						+ text
					);
				}
			}
		</script>
	</body>
</html>
