<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>FantXC Simulator 2019</title>
		<style>
			canvas {
				border: 1px solid black;
				display: inline;
			}
		</style>
	</head>
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
	<body onload="setupRace()">
		<div id="raceDiv">
			<table>
				<tr><td>
					<canvas id="raceCanvas" width="0" height="0"></canvas>
				</td></tr>
				<tr><td>
					<button id="nextRoundButton" onclick="runRace()" disabled="true">Next Round</button>
				</td></tr>
				<tr><td>
					<p id="testP"></p>
				</td></tr>
			</table>
		</div>
		
		<script>
			var runnerList = [];
			var finisherList = [];
			var handSize = 3;
			var raceRoundNum = 0;

			var raceCanvas = $("#raceCanvas")[0];
			var ctx = raceCanvas.getContext("2d");

			var cardList = 
			{
				"Run": new card(1000, 10, ""),
				"Surge": new card(1400, 20, ""),
				"Fatigue": new card(600, 0, ""),
				"Recover": new card(800, 5, "Gain 10% Energy"),
				"Kick": new card(1600, 6, "Expends all available Energy"),
				"Coast": new card(1000, 4, "Can only be used while running with a pack"),
				"Reel In": new card(1200, 10, "Can only be used within 300 meters behind the next runner.")
			};

			function getCardPriority(runner, cardName)
			{
				var priority = 0;
				if (runner.energy < cardList[cardName].energy * (1 + runner.exhaustion))
				{
					priority -= 10000;
				}
				
				switch(cardName)
				{
					case "Kick":
						priority += cardList[cardName].distance;
						var distanceFromFinishAfterKick = 10000 - runner.position - cardList[cardName].distance;
						priority -= distanceFromFinishAfterKick;
						break;
					default:
						priority += cardList[cardName].distance;
						break;
				}
				return priority;
			}

			function card(distance, energy, specialText)
			{
				this.distance = distance;
				this.energy = energy;
				this.specialText = specialText;
			}

			function setupRace()
			{
				raceCanvas.width = window.innerWidth * 0.9;
				raceCanvas.height = window.innerHeight * 0.5;
				setupRaceRunners(10);
				runRace();
			}

			function setupRaceRunners(numRunners)
			{
				runnerList = [];
				finisherList = [];
				for (let i = 0; i < numRunners; i++)
				{
					var runner = new createRunner(runnerList);
					shuffle(runner.deck);
					//deck.length MUST be more than handSize, or this WILL break
					for (let i = 0; i < handSize; i++)
					{
						runner.hand.push(runner.deck.pop());
					}
					runnerList.push(runner);
				}
				showMessage("Race will have " + numRunners + " runners.");
				raceRoundNum = 0;
			}
			
			function drawRunners()
			{
				ctx.clearRect(0, 0, raceCanvas.width, raceCanvas.height);
				var yDistanceBetweenLines = raceCanvas.height/6;
				var xCurveDistance = raceCanvas.width * 0.1;
				ctx.beginPath();
				for (let i = 0; i < 5; i++)
				{
					
					if ((i == 0) || (i == 2))
					{
						ctx.moveTo(xCurveDistance, yDistanceBetweenLines * (i+1));
						ctx.lineTo(raceCanvas.width - xCurveDistance, yDistanceBetweenLines * (i+1));
						ctx.bezierCurveTo(raceCanvas.width - xCurveDistance + xCurveDistance*0.75, yDistanceBetweenLines * (i+1), 
							raceCanvas.width - xCurveDistance + xCurveDistance*0.75, yDistanceBetweenLines * (i+2),
							raceCanvas.width - xCurveDistance, yDistanceBetweenLines * (i+2));
					}
					else if ((i == 1) || (i == 3))
					{
						ctx.moveTo(raceCanvas.width - xCurveDistance, yDistanceBetweenLines * (i+1));
						ctx.lineTo(xCurveDistance, yDistanceBetweenLines * (i+1));
						ctx.bezierCurveTo(xCurveDistance*0.25, yDistanceBetweenLines * (i+1), 
							xCurveDistance*0.25, yDistanceBetweenLines * (i+2),
							xCurveDistance, yDistanceBetweenLines * (i+2));
					}
					else if (i == 4)
					{
						ctx.moveTo(xCurveDistance, yDistanceBetweenLines * (i+1));
						ctx.lineTo(raceCanvas.width - xCurveDistance, yDistanceBetweenLines * (i+1));
					}
				}
				//Mile 1: 1609 on line 0
				//Mile 2: 3218 = 782 on line 1
				//Mile 3: 4828 = 828 on line 2
				//Mile 4: 6437 = 1563 on line 3
				//Mile 5: 8046 = 46 on line 4
				//Mile 6: 9656 = 1656 on line 4
				//ctx.moveTo(
				
				
				ctx.stroke();
			}
			
			function runRace()
			{
				raceRoundNum++;
				showMessage("<strong>Race Round " + raceRoundNum + "</strong>");
				$('#nextRoundButton').prop('disabled', true);
				raceRound();
				updateFinisherList(); //Also updates positionBeforeMoving
				drawRunners();
				if (runnerList.length > finisherList.length)
				{
					$('#nextRoundButton').prop('disabled', false);
				}
			}
			
			function updateFinisherList()
			{
				//Using a temporary list in case we want to introduce an additional tiebreaker later
				var finishersThisTurn = [];
				for (let i = 0; i < runnerList.length; i++)
				{
					var runner = runnerList[i];
					runner.positionBeforeMoving = runner.position;
					if ((runner.position >= 10000) && (runner.finished == false))
					{
						finishersThisTurn.push(runner);
						runner.finished = true;
					}
				}
				finishersThisTurn.sort(dynamicSort("-position"));
				for (let i = 0; i < finishersThisTurn.length; i ++)
				{
					finisherList.push(finishersThisTurn[i]);
					showMessage("Runner " + finishersThisTurn[i].id + " finishes in " + ordinal_suffix_of(finisherList.length) + " place.");
				}
			}
			
			function raceRound()
			{
				showMessage(finisherList.length + " of " + runnerList.length + " runners have finished.");
				runnerList.sort(dynamicSort("position"));
				
				for (let i = 0; i < runnerList.length; i++)
				{
					var runner = runnerList[i];
					if (runner.position < 10000)
					{
						runner.hand.sort(
							function(a,b)
							{
								return getCardPriority(runner, b) - getCardPriority(runner, a);
							}
						);
						
						var isCoastValid = false;
						var isReelInValid = false;
						for (let j = 0; j < runnerList.length; j++)
						{
							var anotherRunner = runnerList[j];
							if (anotherRunner.id != runner.id)
							{
								if (anotherRunner.positionBeforeMoving == runner.position)
								{
									isCoastValid = true;
								}
								else if ((anotherRunner.positionBeforeMoving > runner.position) && (anotherRunner.positionBeforeMoving - runner.position <= 300))
								{
									isReelInValid = true;
								}
								if ((isCoastValid) && (isReelInValid))
								{
									j = runnerList.length;
								}
							}
						}
						
						var cardToPlayIndex = 0;
						while 
						(
							(cardToPlayIndex <= runner.hand.length - 1) //cardToPlayIndex is in hand
							&& 
							(
								(cardList[runner.hand[0]].energy * (1 + runner.exhaustion) > runner.energy) //Card costs too much
								|| ((!isCoastValid) && (runner.hand[cardToPlayIndex] == "Coast")) //Card is Coast and !isCoastValid
								|| ((!isReelInValid) && (runner.hand[cardToPlayIndex] == "Reel In")) //Card is Reel In and !isReelInValid
							)
						)
						{
							cardToPlayIndex++;
						}
						
						
						if (cardToPlayIndex <= runner.hand.length - 1)
						{
							playCard(runner, runner.hand[cardToPlayIndex]);
							runner.discard.push(runner.hand[cardToPlayIndex]);
							runner.hand.splice(cardToPlayIndex, 1);
						}
						else
						{
							playCard(runner, "Fatigue");
						}
						if (runner.deck.length > 0)
						{
							runner.hand.push(runner.deck.pop());
						}
					}
				}
			}

			function playCard(runner, cardName)
			{
				//when cardHandIndex == -1, play fatigue
				var card = cardList[cardName];
				runner.position += card.distance;
				runner.energy -= card.energy * (1 + runner.exhaustion);
				if (cardName == "Recover")
				{
					runner.energy += 10;
				}
				else if (cardName == "Kick")
				{
					runner.energy = 0;
				}
				var distanceFromFinish = 10000 - runner.position;
				
				if (runner.position < 10000)
				{
					showMessage("Runner " + runner.id + " plays " + cardName + " (" + distanceFromFinish + " meters from the finish, " + runner.energy + "% energy remaining).");
				}
				else
				{
					showMessage("Runner " + runner.id + " plays " + cardName + " and crosses the finish line.");
				}
			}
			
			function createRunner(runnerList)
			{
				this.isPlayer = false;
				this.id = runnerList.length;
				this.position = 0;
				this.positionBeforeMoving = 0;
				this.energy = 100;
				this.deck = ["Run", "Run", "Run", "Surge", "Surge", "Recover", "Recover", "Kick", "Coast", "Coast", "Reel In", "Reel In"];
				this.hand = [];
				this.discard = [];
				this.finished = false;
				this.exhaustion = 0;
			}

			//From Stack Overflow: https://stackoverflow.com/questions/1129216/sort-array-of-objects-by-string-property-value
			function dynamicSort(property) 
			{
				var sortOrder = 1;

				if(property[0] === "-") 
				{
					sortOrder = -1;
					property = property.substr(1);
				}
				return function (a,b) 
				{
					var result = (a[property] < b[property]) ? -1 : (a[property] > b[property]) ? 1 : 0;
					return result * sortOrder;
				}
			}

			//From: https://javascript.info/task/shuffle
			function shuffle(array) 
			{
				array.sort(() => Math.random() - 0.5);
			}
			
			//From: https://stackoverflow.com/questions/13627308/add-st-nd-rd-and-th-ordinal-suffix-to-a-number
			function ordinal_suffix_of(i) 
			{
				var j = i % 10,
					k = i % 100;
				if (j == 1 && k != 11) {
					return i + "st";
				}
				if (j == 2 && k != 12) {
					return i + "nd";
				}
				if (j == 3 && k != 13) {
					return i + "rd";
				}
				return i + "th";
			}
			
			function showMessage(text)
			{
				if ($('#testP').html().length == 0)
				{
					$('#testP').html(text);
				}
				else
				{
					$('#testP').html(
						$('#testP').html()
						+ "<br/>"
						+ text
					);
				}
			}
		</script>
	</body>
</html>
